from firebase_functions import firestore_fn
from firebase_functions.firestore_fn import Event, DocumentSnapshot
import requests
import logging
import sys
from functools import wraps
import google.auth
from google.auth.transport.requests import Request
import json

# Cloud LoggingÁî®„ÅÆË®≠ÂÆö
def setup_logging():
    """Cloud LoggingÁî®„ÅÆ„É≠„Ç¨„Éº„ÇíË®≠ÂÆö"""
    # „É´„Éº„Éà„É≠„Ç¨„Éº„ÅÆË®≠ÂÆö
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    
    # Êó¢Â≠ò„ÅÆ„Éè„É≥„Éâ„É©„Éº„Çí„ÇØ„É™„Ç¢
    root_logger.handlers.clear()
    
    # StreamHandler„ÇíËøΩÂä†ÔºàCloud Functions„Åß„ÅØÊ®ôÊ∫ñÂá∫Âäõ„ÅåCloud Logging„Å´Ëª¢ÈÄÅ„Åï„Çå„ÇãÔºâ
    handler = logging.StreamHandler(sys.stdout)
    handler.setLevel(logging.INFO)
    
    # „Éï„Ç©„Éº„Éû„ÉÉ„Çø„Éº„ÇíË®≠ÂÆö
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    handler.setFormatter(formatter)
    
    root_logger.addHandler(handler)
    
    return root_logger

def get_cloud_run_auth_headers(target_url: str) -> dict:
    """Cloud RunË™çË®ºÁî®„ÅÆ„Éò„ÉÉ„ÉÄ„Éº„ÇíÂèñÂæó"""
    try:
        from google.oauth2 import id_token
        from google.auth.transport.requests import Request
        
        # ID„Éà„Éº„ÇØ„É≥„ÇíÂèñÂæóÔºàCloud RunË™çË®ºÁî®Ôºâ
        auth_req = Request()
        id_token_value = id_token.fetch_id_token(auth_req, target_url)
        
        logger.info(f"üîê ID„Éà„Éº„ÇØ„É≥„ÇíÊ≠£Â∏∏„Å´ÂèñÂæó„Åó„Åæ„Åó„Åü for URL: {target_url}")
        
        return {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {id_token_value}"
        }
    except Exception as e:
        logger.error(f"‚ùå ID„Éà„Éº„ÇØ„É≥ÂèñÂæó„Ç®„É©„Éº: {e}")
        # „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: ÂæìÊù•„ÅÆ„Ç¢„ÇØ„Çª„Çπ„Éà„Éº„ÇØ„É≥„Çí‰ΩøÁî®
        logger.info("üîÑ „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ: „Ç¢„ÇØ„Çª„Çπ„Éà„Éº„ÇØ„É≥„Çí‰ΩøÁî®„Åó„Åæ„Åô")
        credentials, project = google.auth.default()
        auth_req = Request()
        credentials.refresh(auth_req)
        
        return {
            "Content-Type": "application/json",
            "Authorization": f"Bearer {credentials.token}"
        }

# „É≠„Ç¨„Éº„ÇíÂàùÊúüÂåñ
logger = setup_logging()

# „Åæ„Åü„ÄÅ„É¢„Ç∏„É•„Éº„É´„É¨„Éô„É´„ÅÆ„É≠„Ç¨„Éº„ÇÇË®≠ÂÆö
module_logger = logging.getLogger(__name__)
module_logger.setLevel(logging.INFO)

def extract_event_info_from_firestore_event(event: Event[DocumentSnapshot | None]):
    """Extract necessary information from Firestore event"""
    try:
        if not event.data:
            return None
        
        doc_data = event.data.to_dict()
        doc_id = event.data.id
        collection_path = event.data.reference.parent.id
        
        return {
            "docData": doc_data,
            "docId": doc_id,
            "collectionFullPath": collection_path
        }
    except Exception as e:
        logger.error(f"Failed to extract event information: {e}")
        return None

def extract_organization_id_from_collection_name(path: str) -> str:
    """Extract organization ID from collection path"""
    try:
        parts = path.split("/")
        if len(parts) >= 2:
            return parts[1]
        return ""
    except Exception as e:
        logger.error(f"Failed to extract organization ID: {e}")
        return ""

def update_document(collectionName, documentId, data):
    """Update Firestore document"""
    try:
        # üéØ Target locked! Writing to collection and document
        logger.info(f"üöÄ FIRESTORE WRITE INCOMING! Collection: '{collectionName}' | Document: '{documentId}'")
        
        from firebase_admin import firestore
        db = firestore.client()
        doc_ref = db.collection(collectionName).document(documentId)
        doc_ref.update(data)
        logger.info(f"‚úÖ Document updated successfully: {collectionName}/{documentId}")
    except Exception as e:
        logger.error(f"‚ùå Failed to update document: {e}")

def saveLog(logType: str, logMessage: str, isWriteToDoc: bool = False, docInfo: dict = None):
    """Save log with improved Cloud Logging support"""
    try:
        # Cloud Logging„Å´Á¢∫ÂÆü„Å´Âá∫Âäõ„Åô„Çã„Åü„ÇÅ„ÄÅprint„ÇÇ‰ΩµÁî®
        log_entry = f"[{logType.upper()}] {logMessage}"
        print(log_entry)  # Cloud Functions„Åß„ÅØ print „ÇÇ Cloud Logging „Å´Ëª¢ÈÄÅ„Åï„Çå„Çã
        
        if logType == "info":
            logger.info(logMessage)
        elif logType == "error":
            logger.error(logMessage)
        elif logType == "warning":
            logger.warning(logMessage)
        elif logType == "debug":
            logger.debug(logMessage)
        
        if isWriteToDoc and docInfo:
            from firebase_admin import firestore
            update_document(
                collectionName=docInfo["collectionName"],
                documentId=docInfo["docId"],
                data={
                    f"logs": firestore.ArrayUnion([{
                        "type": logType,
                        "message": logMessage,
                        "timestamp": firestore.SERVER_TIMESTAMP
                    }])
                }
            )
    except Exception as e:
        print(f"[ERROR] Failed to save log: {e}")
        logger.error(f"Failed to save log: {e}")

@firestore_fn.on_document_created(
    document="organizations/{organizationId}/requests/convertPdfToPngAndCaptureRequests/logs/{requestId}",
    memory=1024,
    timeout_sec=300
)
def convert_pdf_to_png_and_capture_job(event: Event[DocumentSnapshot | None]) -> None:
    try:
        # Extract necessary information from event
        event_data = extract_event_info_from_firestore_event(event)
        if not event_data:
            logger.warning("No event data found, returning early")
            return
        doc_info = extract_event_info_from_firestore_event(event)
        fields = doc_info["docData"]
        request_id = doc_info["docId"]
        organization_id = fields["input"]["organizationId"]
        blueprint_id = fields["input"]["blueprintId"]
        
        # „É≠„Ç∞„ÇíÂº∑Âåñ„Åó„Å¶Á¢∫ÂÆü„Å´Âá∫Âäõ
        print(f"[INFO] Processing PDF conversion request: {request_id}")
        logger.info(f"Fields: {fields}")
        logger.info(f"Request ID: {request_id}")
        logger.info(f"Organization ID: {organization_id}")
        logger.info(f"Blueprint ID: {blueprint_id}")
        
        # Convert PDF to PNG and save
        url = "https://convert-pdf-to-png-and-capture-208707381956.us-central1.run.app/convert-pdf-to-png"
        payload = {
            "bucket_name": "knockai-106a4.firebasestorage.app",
            "gcsInputPdfFilePath": f"organizations/{organization_id}/blueprints/{blueprint_id}/pdf/blueprint.pdf",
            "gcsOutputPreviewPngFilePath": f"organizations/{organization_id}/blueprints/{blueprint_id}/png/blueprint.png"
        }
        
        # Get authentication headers for Cloud Run
        headers = get_cloud_run_auth_headers(url)
        
        logger.info(f"Sending request to: {url}")
        response = requests.post(url, json=payload, headers=headers)
        response.raise_for_status()
        
        print(f"[INFO] Successfully converted PDF to PNG: {response.json()}")
        logger.info(f"Successfully converted PDF to PNG: {response.json()}")
        
        # Save Blueprint data to Firestore
        update_document(
            collectionName=f"organizations/{organization_id}/requests/convertPdfToPngAndCaptureRequests/logs",
            documentId=request_id,
            data={
                "status": "completed",
            }
        )
        print(f"[INFO] Process completed successfully for request: {request_id}")
    except Exception as e:
        error_msg = f"Failed to convert PDF to PNG and capture pages: {e}"
        print(f"[ERROR] {error_msg}")
        logger.error(error_msg)


@firestore_fn.on_document_created(
    document="organizations/{organizationId}/requests/startEstimateCreateProcessRequests/logs/{requestId}",
    memory=1024,
    timeout_sec=300
)
def start_estimate_create_process(event: Event[DocumentSnapshot | None]) -> None:
    try:
        # Extract necessary information from event
        event_data = extract_event_info_from_firestore_event(event)
        if not event_data:
            logger.warning("No event data found, returning early")
            return
        doc_info = extract_event_info_from_firestore_event(event)
        fields = doc_info["docData"]
        request_id = doc_info["docId"]
        organization_id = fields["input"]["organizationId"]
        session_id = fields["input"]["sessionId"]
        app_name = fields["input"]["appName"]
        user_id = fields["input"]["userId"]
        
        # „É≠„Ç∞„ÇíÂº∑Âåñ„Åó„Å¶Á¢∫ÂÆü„Å´Âá∫Âäõ
        print(f"[INFO] Starting estimate create process: {session_id}")
        logger.info(f"Fields: {fields}")
        logger.info(f"Request ID: {request_id}")
        logger.info(f"Organization ID: {organization_id}")
        logger.info(f"Session ID: {session_id}")
        logger.info(f"App Name: {app_name}")
        logger.info(f"User ID: {user_id}")
        
        # Create new session
        session_url = f"https://adk-default-service-name-208707381956.us-central1.run.app/apps/{app_name}/users/{user_id}/sessions/{session_id}"
        
        # Get authentication headers for Cloud Run
        headers = get_cloud_run_auth_headers(session_url)
        
        logger.info(f"Sending request to create session: {session_url}")
        
        # Send POST request to create new session
        response = requests.post(session_url, headers=headers)
        response.raise_for_status()
        
        print(f"[INFO] Successfully created new session: {response.text}")
        logger.info(f"Successfully created new session: {response.text}")
        
        # Update document status to completed
        update_document(
            collectionName=f"organizations/{organization_id}/requests/startEstimateCreateProcessRequests/logs",
            documentId=request_id,
            data={
                "status": "completed",
            }
        )
        
        success_msg = f"Estimate create process started successfully for session_id: {session_id}"
        print(f"[INFO] {success_msg}")
        logger.info(success_msg)
        
    except Exception as e:
        error_msg = f"Failed to start estimate create process: {e}"
        print(f"[ERROR] {error_msg}")
        logger.error(error_msg)
        
        # Update document status to failed
        try:
            update_document(
                collectionName=f"organizations/{organization_id}/requests/startEstimateCreateProcessRequests/logs",
                documentId=request_id,
                data={
                    "status": "failed"
                }
            )
        except Exception as update_error:
            update_error_msg = f"Failed to update document status to failed: {update_error}"
            print(f"[ERROR] {update_error_msg}")
            logger.error(update_error_msg)


@firestore_fn.on_document_created(
    document="organizations/{organizationId}/requests/sendQueryToGoogleAgentRequests/logs/{requestId}",
    memory=1024,
    timeout_sec=300
)
def send_query_to_google_agent(event: Event[DocumentSnapshot | None]) -> None:
    try:
        # üéØ „Ç§„Éô„É≥„Éà„Åã„ÇâÂøÖË¶Å„Å™ÊÉÖÂ†±„ÇíÊäΩÂá∫
        event_data = extract_event_info_from_firestore_event(event)
        if not event_data:
            logger.warning("‚ùå „Ç§„Éô„É≥„Éà„Éá„Éº„Çø„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÅÊó©Êúü„É™„Çø„Éº„É≥„Åó„Åæ„Åô")
            return
        doc_info = extract_event_info_from_firestore_event(event)
        fields = doc_info["docData"]
        request_id = doc_info["docId"]
        organization_id = fields["input"]["organizationId"]
        session_id = fields["input"]["sessionId"]
        app_name = fields["input"]["appName"]
        user_id = fields["input"]["userId"]
        query = fields["input"]["query"]
        
        # üíæ „Ç®„Éº„Ç∏„Çß„É≥„Éà„É¨„Çπ„Éù„É≥„Çπ„Å®ÂÖ±„Å´„Éâ„Ç≠„É•„É°„É≥„Éà„Çπ„ÉÜ„Éº„Çø„Çπ„ÇíÂÆå‰∫Ü„Å´Êõ¥Êñ∞
        collection_path = f"organizations/{organization_id}/requests/sendQueryToGoogleAgentRequests/logs"        
        
        # üìù „É≠„Ç∞„ÇíÂº∑Âåñ„Åó„Å¶Á¢∫ÂÆü„Å´Âá∫Âäõ
        logger.info(f"ü§ñ Google Agent„Å´„ÇØ„Ç®„É™„ÇíÈÄÅ‰ø°‰∏≠: {query[:50]}...")
        logger.info(f"üìã Fields: {fields}")
        logger.info(f"üÜî Request ID: {request_id}")
        logger.info(f"üè¢ Organization ID: {organization_id}")
        logger.info(f"üí¨ Session ID: {session_id}")
        logger.info(f"üì± App Name: {app_name}")
        logger.info(f"üë§ User ID: {user_id}")
        logger.info(f"‚ùì Query: {query}")
        
        # üì¶ Google Agent APIÁî®„ÅÆ„Éö„Ç§„É≠„Éº„Éâ„ÇíÊ∫ñÂÇô
        payload = {
            "appName": app_name,
            "userId": user_id,
            "sessionId": session_id,
            "newMessage": {
                "role": "user",
                "parts": [{
                    "text": query
                }]
            }
        }
        
        # üöÄ Google Agent„Å´„ÇØ„Ç®„É™„ÇíÈÄÅ‰ø°
        agent_url = "https://adk-default-service-name-208707381956.us-central1.run.app/run_sse"
        
        # üîê Ë™çË®º„Éò„ÉÉ„ÉÄ„Éº„ÇíÂèñÂæó
        headers = get_cloud_run_auth_headers(agent_url)
        
        logger.info(f"üåê Google Agent„Å´„ÇØ„Ç®„É™„ÇíÈÄÅ‰ø°‰∏≠: {agent_url}")
        logger.info(f"üì§ Payload: {payload}")
        
        # üì° POST„É™„ÇØ„Ç®„Çπ„Éà„ÇíGoogle Agent„Å´ÈÄÅ‰ø°
        response = requests.post(agent_url, json=payload, headers=headers)
        response.raise_for_status()
        
        # üìä „É¨„Çπ„Éù„É≥„Çπ„ÅÆË©≥Á¥∞„É≠„Ç∞„ÇíÂº∑Âåñ
        logger.info(f"‚úÖ Google Agent response status: {response.status_code}")
        logger.info(f"üìã Google Agent response headers: {dict(response.headers)}")
        logger.info(f"üìÑ Google Agent raw response text (length: {len(response.text)}): {repr(response.text)}")
        
        # üîç „É¨„Çπ„Éù„É≥„Çπ„ÇíËß£Êûê„Åó„Å¶„Ç®„Éº„Ç∏„Çß„É≥„Éà„ÅÆËøîÁ≠î„ÇíÊäΩÂá∫
        try:
            # üìù Ë§áÊï∞„ÅÆ data: „Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ‰ªò„ÅçJSONÊñáÂ≠óÂàó„ÇíÂá¶ÁêÜ
            response_text = response.text.strip()            
            logger.info(f"üîç „É¨„Çπ„Éù„É≥„Çπ„ÉÜ„Ç≠„Çπ„Éà„ÇíÂá¶ÁêÜ‰∏≠: {repr(response_text)}")
            
            # üßπ Ë§áÊï∞„ÅÆ "data: " Ë°å„ÇíÂàÜÂâ≤„Åó„Å¶Âá¶ÁêÜ
            data_lines = []
            for line in response_text.split('\n'):
                line = line.strip()
                if line.startswith("data: "):
                    json_str = line[6:]  # "data: "„Éó„É¨„Éï„Ç£„ÉÉ„ÇØ„Çπ„ÇíÂâäÈô§
                    data_lines.append(json_str)
                    logger.info(f"üßπ dataË°å„ÇíÁô∫Ë¶ã„ÄÅJSONÊñáÂ≠óÂàó: {repr(json_str)}")
            
            # üìä Ë¶ã„Å§„Åã„Å£„ÅüdataË°å„ÅÆÊï∞„Çí„É≠„Ç∞Âá∫Âäõ
            logger.info(f"üìä Ë¶ã„Å§„Åã„Å£„ÅüdataË°å„ÅÆÊï∞: {len(data_lines)}")
            
            # üîÑ dataË°å„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØÂÖÉ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„Çí‰ΩøÁî®
            if not data_lines:
                logger.info(f"‚ÑπÔ∏è dataË°å„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì„ÄÅÂÖÉ„ÅÆ„ÉÜ„Ç≠„Çπ„Éà„ÇíÂçò‰∏ÄJSON„Å®„Åó„Å¶Âá¶ÁêÜ")
                data_lines = [response_text]
            
            # üìù ÂÖ®„Å¶„ÅÆdataË°å„Åã„Çâparts„ÇíÊäΩÂá∫
            all_agent_parts = []
            
            for i, json_str in enumerate(data_lines):
                try:
                    logger.info(f"üîß dataË°å {i+1}/{len(data_lines)} „ÅÆJSON„ÇíËß£Êûê‰∏≠: {repr(json_str)}")
                    response_data = json.loads(json_str)
                    logger.info(f"‚úÖ dataË°å {i+1} „ÅÆJSON„É¨„Çπ„Éù„É≥„ÇπËß£Êûê„Å´ÊàêÂäü: {response_data}")
                    
                    # üìù content.parts„Åã„Çâ„ÉÜ„Ç≠„Çπ„Éà„ÇíÊäΩÂá∫
                    if "content" in response_data:
                        logger.info(f"‚úÖ dataË°å {i+1} „Åß'content'„Ç≠„Éº„ÇíÁô∫Ë¶ã")
                        
                        if "parts" in response_data["content"]:
                            logger.info(f"‚úÖ dataË°å {i+1} „ÅÆcontentÂÜÖ„Åß'parts'„ÇíÁô∫Ë¶ã: {response_data['content']['parts']}")
                            
                            # üîÑ ÂêÑ„Éë„Éº„Éà„Çí all_agent_parts „Å´ËøΩÂä†
                            for j, part in enumerate(response_data["content"]["parts"]):
                                logger.info(f"üîç dataË°å {i+1} „ÅÆ„Éë„Éº„Éà {j} „ÇíÂá¶ÁêÜ‰∏≠: {part}")
                                all_agent_parts.append(part)
                                logger.info(f"‚úÖ dataË°å {i+1} „ÅÆ„Éë„Éº„Éà {j} „ÇíËøΩÂä†")
                        else:
                            logger.warning(f"‚ö†Ô∏è dataË°å {i+1} „ÅÆcontentÂÜÖ„Åß'parts'„Ç≠„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì")
                    else:
                        logger.warning(f"‚ö†Ô∏è dataË°å {i+1} „Åß'content'„Ç≠„Éº„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì")
                        
                except json.JSONDecodeError as json_error:
                    logger.error(f"‚ùå dataË°å {i+1} „ÅÆJSON decode error: {json_error}")
                    logger.error(f"‚ùå dataË°å {i+1} „ÇíJSON„Å®„Åó„Å¶Ëß£Êûê„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü: {repr(json_str)}")
                    # üîÑ JSON„Éë„Éº„Çπ„Å´Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÅØ„ÉÜ„Ç≠„Çπ„Éà„Å®„Åó„Å¶ËøΩÂä†
                    all_agent_parts.append({"text": json_str})
                except Exception as parse_error:
                    logger.error(f"‚ùå dataË°å {i+1} „ÅÆËß£Êûê„Ç®„É©„Éº: {parse_error}")
                    all_agent_parts.append({"text": json_str})
            
            # üîÑ „Éë„Éº„ÉÑ„ÅåË¶ã„Å§„Åã„Çâ„Å™„ÅÑÂ†¥Âêà„ÅØ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
            if not all_agent_parts:
                logger.warning(f"‚ö†Ô∏è „Ç®„Éº„Ç∏„Çß„É≥„Éà„Éë„Éº„ÉÑ„ÅåÊäΩÂá∫„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÅ„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ„Çí‰ΩøÁî®")
                all_agent_parts = [{"text": "No response content found"}]
            
            # üìä ÊúÄÁµÇÁöÑ„Å™agent_parts„ÅÆ„É≠„Ç∞Âá∫Âäõ
            logger.info(f"üéØ ÊúÄÁµÇÁöÑ„Å´ÊäΩÂá∫„Åï„Çå„Åü„Ç®„Éº„Ç∏„Çß„É≥„Éà„Éë„Éº„ÉÑÊï∞: {len(all_agent_parts)}")
            logger.info(f"üéØ ÊúÄÁµÇÁöÑ„Å´ÊäΩÂá∫„Åï„Çå„Åü„Ç®„Éº„Ç∏„Çß„É≥„Éà„Éë„Éº„ÉÑ: {all_agent_parts}")
            
            agent_parts = all_agent_parts
            
            update_document(
                collectionName=collection_path,
                documentId=request_id,
                data={
                    "status": "completed",
                    "output": {
                        "parts": agent_parts
                    }
                }
            )
            
        except json.JSONDecodeError as json_error:
            logger.error(f"‚ùå JSON decode error: {json_error}")
            logger.error(f"‚ùå „É¨„Çπ„Éù„É≥„Çπ„ÇíJSON„Å®„Åó„Å¶Ëß£Êûê„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇÁîü„É¨„Çπ„Éù„É≥„Çπ: {repr(response.text)}")
            
            # üîÑ JSON„Éë„Éº„Çπ„Å´Â§±Êïó„Åó„ÅüÂ†¥Âêà„ÄÅ„É¨„Çπ„Éù„É≥„Çπ„ÉÜ„Ç≠„Çπ„Éà„Çí„Åù„ÅÆ„Åæ„Åæ‰ΩøÁî®
            collection_path = f"organizations/{organization_id}/requests/sendQueryToGoogleAgentRequests/logs"
            update_document(
                collectionName=collection_path,
                documentId=request_id,
                data={
                    "status": "completed",
                    "output": {
                        "parts": [{"text": response.text}],
                        "rawResponse": response.text
                    }
                }
            )
        except Exception as parse_error:
            logger.error(f"Parse error: {parse_error}")
            logger.error(f"Failed to parse response, treating as plain text. Raw response: {repr(response.text)}")
            
            # Fallback: treat response as plain text
            collection_path = f"organizations/{organization_id}/requests/sendQueryToGoogleAgentRequests/logs"
            update_document(
                collectionName=collection_path,
                documentId=request_id,
                data={
                    "status": "completed",
                    "output": {
                        "parts": [{"text": response.text}]
                    }
                }
            )
        
        success_msg = f"Query sent successfully to Google Agent for session: {session_id}"
        logger.info(success_msg)
        
    except Exception as e:
        error_msg = f"Failed to send query to Google Agent: {e}"
        logger.error(error_msg)
        
        # Update document status to failed
        try:
            # Extract organization_id safely for error handling
            organization_id = ""
            if event and event.data:
                doc_data = event.data.to_dict()
                if doc_data and "input" in doc_data and "organizationId" in doc_data["input"]:
                    organization_id = doc_data["input"]["organizationId"]
            
            collection_path = f"organizations/{organization_id}/requests/sendQueryToGoogleAgentRequests/logs" if organization_id else f"requests/sendQueryToGoogleAgentRequests/logs"
            update_document(
                collectionName=collection_path,
                documentId=request_id,
                data={
                    "status": "failed"
                }
            )
        except Exception as update_error:
            update_error_msg = f"Failed to update document status to failed: {update_error}"
            logger.error(update_error_msg)